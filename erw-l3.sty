%%
%% This is file `erw-l3.sty',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% erw-l3.dtx  (with options: `package')
%% ----------------------------------------------------------------------------
%% erw-l3 --- LaTeX3 utilities.
%% Released under the LaTeX Project Public License v1.3c or later
%% See http://www.latex-project.org/lppl.txt
%% ----------------------------------------------------------------------------
%% 
 \NeedsTeXFormat{LaTeX2e}[2020/02/02]
 \RequirePackage{etoolbox}[2019/09/21]
 \RequirePackage{l3keys2e}[2020/03/06]
 \RequirePackage{xparse}[2020/03/06]
 \ProvidesExplPackage
 {erw-l3}                                                                                 % Package name
 {2020/04/27}                                                                             % Release date
 {0.7}                                                                                    % Release version
 {erw-l3 --- LaTeX3 utilities. }                                                          % Description
%%   \clearpage
\ExplSyntaxOn
\cs_set:Npn \@@_cs_name:N #1
{
  \exp_last_unbraced:Nf \use_i:nnn {\cs_split_function:N #1}
}
\cs_set:Npn \erw_cs_apply:Nnn #1 #2 #3
{
  #1{#2}{#3}
}
\cs_set:Npn \erw_cs_apply:Nnnn #1 #2 #3 #4
{
  #1{#2}{#3}{#4}
}
\cs_set:Npn \erw_cs_apply:Nnnnn #1 #2 #3 #4 #5
{
  #1{#2}{#3}{#4}{#5}
}
\cs_set:Npn \erw_cs_apply:Nn
#1 % fun
#2 % tl
{
  #1{#2}
}
\cs_generate_variant:Nn \erw_cs_apply:Nn {No, Nf, Nx, c}
\cs_set:Npn \erw_cs_set_eq:NN #1 #2
{
  \cs_set:Npn #1 ##1{#2{##1}}
}
\cs_generate_variant:Nn \erw_cs_set_eq:NN {cN}
\cs_set:Npn \erw_cs_gset_eq:NN #1 #2
{
  \cs_gset:Npn #1 ##1{#2{##1}}
}
\cs_generate_variant:Nn \erw_cs_gset_eq:NN {cN}
\cs_set:Npn \erw_cs_set_inline:Nn #1 #2
{
  \cs_set:Npn #1 ##1{#2}
}
\cs_generate_variant:Nn \erw_cs_set_inline:Nn {cn}
\cs_set:Npn \erw_cs_gset_inline:Nn #1 #2
{
  \cs_gset:Npn #1 ##1{#2}
}
\cs_generate_variant:Nn \erw_cs_gset_inline:Nn {cn}
\cs_set:Npn \erw_identity:n #1{#1}
\cs_set:Npn \@@_int_range:nnn #1 #2 #3
{
  \int_compare:nNnTF
  {
    \int_eval:n{#2+1}
  }>{#3}
  {
    {#1}
  }
  {
    \@@_int_range:nnn
    {
      \exp_args:Nx\erw_accum:nn{#1}
      {
        \int_eval:n{#2+1}
      }
    }
    {\int_eval:n{#2+1}}
    {#3}
  }
}
\cs_set:Npn \erw_int_range:nn #1 #2
{
  \@@_int_range:nnn {{#1}}{#1}{#2}
}
\cs_set:Npn \erw_int_range:n #1
{
  \@@_int_range:nnn {}{0}{#1}
}
\cs_set:Npn \erw_accum:nn #1 #2
{
  {#1{#2}}
}
\cs_set:Npn \erw_compose:NnV
#1 % method
#2 % funs
#3 % var
{
  \erw_cs_set_inline:Nn \@@_map:n
  {
    #1{##1}#3
  }
  \exp_args:Nf\erw_map:n
  {
    \tl_reverse:n{#2}
  }
}
\cs_set:Npn \erw_compose:nV #1 #2
{
  \erw_compose:NnV \erw_fold:NV {#1} #2
}
\cs_set:Npn \erw_compose_c:nV #1 #2
{
  \erw_compose:NnV \erw_fold:cV {#1} #2
}
\tl_new:N \g@@_compose_tl
\cs_set:Npn \erw_compose:nn #1 #2
{
  \tl_set:Nn \g@@_compose_tl {#2}
  \erw_compose:nV{#1}\g@@_compose_tl
  \g@@_compose_tl
}
\cs_set:Npn \erw_compose_c:nn #1 #2
{
  \tl_set:Nn \g@@_compose_tl {#2}
  \erw_compose_c:nV{#1}\g@@_compose_tl
  \g@@_compose_tl
}
\cs_set:Npn \erw_compose_vers:nV #1 #2
{
  \msg_error:nnn{erw}{generic}{erw_compose_vers:nV~yet-to~be~implemented}
}
\cs_set:Npn \erw_compose_vers:nn #1 #2
{
  \erw_cs_no_reset:{}
  \tl_map_function:nN{#1}\erw_cs_no_new:n
  \exp_last_unbraced:Nx
  \erw_compose_c:nn
  {{\erw_cs_no_names_braced:{}}}
  {#2}
}
\cs_set:Npn \erw_compose_seq:nV #1 #2
{
  \erw_compose:NnV \erw_seq_fold:NV {#1} #2
}
\cs_set:Npn \erw_compose_seq_c:nV
#1 % funs
#2 % seq
{
  \erw_compose:NnV \erw_seq_fold:cV {#1} #2
}
\cs_set:Npn \erw_compose_seq_vers:nV #1 #2
{
  \msg_error:nnn{erw}{generic}{erw_compose_seq_vers:nV~yet-to~be~implemented}
}
\tl_new:N \g@@_seq_fold_item_tl
\cs_set:Npn \erw_seq_fold:NV
#1 % fun
#2 % seq
{
  \seq_get_right:NN #2 \g@@_seq_fold_item_tl
  \erw_fold:NV #1 \g@@_seq_fold_item_tl
  \seq_put_right:No #2 {\g@@_seq_fold_item_tl}
}
\cs_generate_variant:Nn \erw_seq_fold:NV {cV}
\cs_set:Npn \erw_fold:NV
#1 % fun
#2 % var
{
  \use:c{tl_set:\g@@_fold_set_par_tl}
  #2
  {\use:c{erw_cs_apply:\g@@_fold_apply_par_tl}{#1}{#2}}
}
\cs_generate_variant:Nn \erw_fold:NV {cV}
\cs_new:Nn \@@_sys_date:
{
  \int_eval:n
  {
    \c_sys_year_int * 10000
    +\c_sys_month_int * 100
    +\c_sys_day_int *  1
  }
}
\cs_new:Nn\erw_sys_date:{\@@_sys_date:}
\cs_new:Nn \@@_sys_date_hex:
{\int_to_hex:n{\@@_sys_date:}}
\cs_new:Nn\erw_sys_date_hex:{\@@_sys_date_hex:}
\cs_new:Nn\@@_sys_filename:
{
  \c_sys_jobname_str--
  \@@_sys_date_hex:--
  \@@_sys_time_hex:
}
\cs_new:Nn\erw_sys_filename:{\@@_sys_filename:}
\cs_new:Nn \@@_sys_time:
{
  \int_eval:n
  {
    \c_sys_hour_int * 100
    +\c_sys_minute_int * 1
  }
}
\cs_new:Nn\erw_sys_time:{\@@_sys_time:}
\cs_new:Nn\@@_sys_time_hex:
{\int_to_hex:n{\@@_sys_time:}}
\cs_new:Nn \erw_sys_time_hex:{\@@_sys_time_hex:}
\prg_set_conditional:Npnn \erw_is_matrix:n #1 { p, TF }
{
  \erw_gset_map_inline:n{==\tl_count:n{##1}}
  \int_compare:nTF
  {
    \exp_args:Nf\tl_count:n{\tl_head:n{#1}}
    \exp_args:Nf \erw_map:n
    {
      \tl_tail:n{#1}
    }
  }
  {\prg_return_true:}
  {\prg_return_false:}
}
\cs_set:Npn \erw_gset_map:N #1
{
  \erw_cs_gset_eq:NN \@@_map:n #1
}
\cs_set:Npn \erw_gset_map_inline:n #1
{
  \erw_cs_gset_inline:Nn \@@_map:n {#1}
}
\cs_set:Npn \erw_last_item:n #1
{
  \exp_args:Nof \tl_item:nn
  {#1}
  {
    \tl_count:n{#1}
  }
}
\cs_set:Npn \erw_map:n #1
{
  \@@_map:nn#1\q_recursion_tail\q_recursion_stop\q_recursion_tail\q_recursion_stop
}
\cs_set:Npn \@@_map:nn #1 #2
{
  \quark_if_recursion_tail_stop:n{#1}
  \@@_map:n{#1}  \@@_map:nn{#2}
}
\cs_new:Npn \@@_map:n #1
{
  \msg_error:nnn
  {erw}
  {generic}
  {@@_map:n~not~set}
}
\cs_set:Npn \erw_map:Nn
#1 % fun
#2 % tl
{
  \erw_cs_set_eq:NN \@@_map:n #1
  \erw_map:n{#2}
}
\cs_set:Npn \erw_map_inline:nn
#1 % inl
#2 % tl
{
  \erw_cs_set_inline:Nn \@@_map:n {#1}
  \erw_map:n{#2}
}
\cs_set:Npn \erw_merge:nn #1 #2
{
  {#1#2}
}
\cs_set:Npn \erw_repeat:nn #1 #2
{
  \int_step_inline:nnnn{1}{1}{#1}{#2}
}
\cs_set:Npn \erw_split:nnn #1 #2 #3
{
  \tl_head:n{#1}
  \use:c{exp_args:#3} \tl_map_inline:nn
  {
    \tl_tail:n
    {
      #1
    }
  }{#2##1}
}
\cs_set:Npn \erw_split:nn #1 #2
{
  \erw_split:nnn{#1}{#2}{Nf}
}
\cs_set:Npn \@@_map_thread_at:Nnn #1 #2 #3
{
  \erw_cs_apply:Nn #1
  {\exp_args:Nf\tl_item:nn {#3} {#2} }
}
\cs_set:Npn \@@_map_thread_at:Nnnn #1 #2 #3 #4
{
  \erw_cs_apply:Nnn #1
  {\exp_args:Nf\tl_item:nn {#3} {#2} }
  {\exp_args:Nf\tl_item:nn {#4} {#2} }
}
\cs_set:Npn \@@_map_thread_at:Nnnnn #1 #2 #3 #4 #5
{
  \erw_cs_apply:Nnnn #1
  {\exp_args:Nf\tl_item:nn {#3} {#2} }
  {\exp_args:Nf\tl_item:nn {#4} {#2} }
  {\exp_args:Nf\tl_item:nn {#5} {#2} }
}
\cs_set:Npn \@@_map_thread_at:Nnnnnn #1 #2 #3 #4 #5 #6
{
  \erw_cs_apply:Nnnnn #1
  {\exp_args:Nf\tl_item:nn {#3} {#2} }
  {\exp_args:Nf\tl_item:nn {#4} {#2} }
  {\exp_args:Nf\tl_item:nn {#5} {#2} }
  {\exp_args:Nf\tl_item:nn {#6} {#2} }
}
\cs_set:Npn \erw_map_thread_at:Nnn #1 #2 #3
{
  \exp_args:Nf\int_case:nnTF
  {
    \tl_count:n{#3}
  }
  {
    {1}{ \@@_map_thread_at:Nnn #1{#2}#3 }
    {2}{ \@@_map_thread_at:Nnnn #1{#2}#3 }
    {3}{ \@@_map_thread_at:Nnnnn #1{#2}#3 }
    {4}{ \@@_map_thread_at:Nnnnnn #1{#2}#3 }
  }
  {
    % Do nothing
  }
  {
    \msg_error:nnn{erw}
    {generic}
    {erw_map_thread_at:~count~of~#3~not~withing~1~to~4}
  }
}
\cs_set:Npn \erw_map_thread:Nn #1 #2
{
  % TODO check that #2 is a matrix
  \int_step_inline:nn
  {
    \exp_args:Nf \tl_count:n{ \tl_head:n{#2} }
  }
  {
    \erw_map_thread_at:Nnn #1 {##1} {#2}
  }
}
\int_new:N \g@@_cs_no_int
\cs_set:Npn \erw_cs_no_name:n #1{@@_cs_no_\int_to_alph:n{#1}:n}
\cs_set:Npn \erw_cs_no_name_braced:n #1{{\erw_cs_no_name:n{#1}}}
\tl_set:Nn \g@@_cs_no_name_tl {\erw_cs_no_name:n{\g@@_cs_no_int}}
\cs_set:Npn \erw_cs_no:nn #1 #2
{
  \erw_cs_apply:cn{@@_cs_no_\int_to_alph:n{#1}:n}{#2}
}
\cs_new_protected:Npn \erw_cs_no_reset:
{
  \int_zero:N \g@@_cs_no_int
  \tl_set:Nn \@@_cs_no_ext_tl{}%^^A remove
}
\cs_new_protected:Npn \erw_cs_no_new:n #1
{
  \int_incr:N \g@@_cs_no_int
  \erw_cs_set_inline:cn{\g@@_cs_no_name_tl}
  {
    \token_if_cs:NTF
    {#1}
    {#1{##1}}
    {#1}
  }
}
\cs_new:Npn \erw_cs_no_names:nnn #1 #2 #3
{
  \int_step_function:nnnN { #1 }{ #2 }{ #3 } \erw_cs_no_name:n
}
\cs_new:Npn \erw_cs_no_names_braced:nnn #1 #2 #3
{
  \int_step_function:nnnN { #1 }{ #2 }{ #3 } \erw_cs_no_name_braced:n
  % TODO \tl_range_braced:nnn?
}
\cs_new:Npn \erw_cs_no_names_braced:
{
  \erw_cs_no_names_braced:nnn{1}{1}{\g@@_cs_no_int}
}
\keys_define:nn{@@}
{
  fold/set_par. tl_set:N = \g@@_fold_set_par_tl,
  fold/set_par. value_required:n = true,
  fold/set_par. default:n = Nf,
  fold/set_par. initial:n = Nf,
  fold/apply_par. tl_set:N = \g@@_fold_apply_par_tl,
  fold/apply_par. value_required:n = true,
  fold/apply_par. default:n = Nf,
  fold/apply_par. initial:n = Nf
}
\ExplSyntaxOff
%% 
%% Copyright (C) 2020 by Erwann Rogard
%% 
%% This work may be distributed and/or modified under the
%% conditions of the LaTeX Project Public License (LPPL), either
%% version 1.3c of this license or (at your option) any later
%% version.  The latest version of this license is in the file:
%% 
%% http://www.latex-project.org/lppl.txt
%% 
%% This work is "maintained" (as per LPPL maintenance status) by
%% Erwann Rogard.
%% 
%% This work consists of the file erw-l3.dtx and the derived files:
%% erw-l3.sty, and erw-l3.pdf.
%% 
%%
%% End of file `erw-l3.sty'.
